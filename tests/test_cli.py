"""Tests for the GirlBot CLI."""

import os
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from click.testing import CliRunner

from src.cli import (
    FEATURES,
    check_api_key_format,
    get_env_path,
    load_env_file,
    main,
    save_env_file,
)


class TestEnvHelpers:
    """Tests for environment file helpers."""

    def test_get_env_path(self):
        """Test getting the .env path."""
        path = get_env_path()
        assert path.name == ".env"
        assert path.parent == Path.cwd()

    def test_load_env_file_empty(self, tmp_path):
        """Test loading an empty env file."""
        env_file = tmp_path / ".env"
        env_file.write_text("")

        result = load_env_file(env_file)
        assert result == {}

    def test_load_env_file_with_content(self, tmp_path):
        """Test loading an env file with content."""
        env_file = tmp_path / ".env"
        env_file.write_text("""
# Comment
KEY1=value1
KEY2="quoted value"
KEY3='single quoted'

EMPTY_LINE_ABOVE=test
""")

        result = load_env_file(env_file)
        assert result["KEY1"] == "value1"
        assert result["KEY2"] == "quoted value"
        assert result["KEY3"] == "single quoted"
        assert result["EMPTY_LINE_ABOVE"] == "test"

    def test_load_env_file_nonexistent(self, tmp_path):
        """Test loading a nonexistent env file."""
        env_file = tmp_path / "nonexistent"
        result = load_env_file(env_file)
        assert result == {}

    def test_save_env_file(self, tmp_path):
        """Test saving an env file."""
        env_file = tmp_path / ".env"
        env = {"KEY1": "value1", "KEY2": "value2"}

        save_env_file(env_file, env)

        content = env_file.read_text()
        assert "KEY1=value1" in content
        assert "KEY2=value2" in content
        assert "Generated by 'girlbot init'" in content


class TestApiKeyValidation:
    """Tests for API key format validation."""

    def test_telegram_token_valid(self):
        """Test valid Telegram token format."""
        valid, msg = check_api_key_format(
            "TELEGRAM_BOT_TOKEN",
            "123456789:ABCdefGHIjklMNOpqrSTUvwxYZ1234567890"
        )
        assert valid is True
        assert msg == "Format OK"

    def test_telegram_token_invalid_no_colon(self):
        """Test invalid Telegram token without colon."""
        valid, msg = check_api_key_format(
            "TELEGRAM_BOT_TOKEN",
            "invalid_token_without_colon"
        )
        assert valid is False
        assert "should be like" in msg.lower()

    def test_telegram_token_too_short(self):
        """Test too short Telegram token."""
        valid, msg = check_api_key_format(
            "TELEGRAM_BOT_TOKEN",
            "123:abc"
        )
        assert valid is False

    def test_openai_key_valid(self):
        """Test valid OpenAI key format."""
        valid, msg = check_api_key_format(
            "OPENAI_API_KEY",
            "sk-proj-1234567890abcdef"
        )
        assert valid is True

    def test_openai_key_invalid(self):
        """Test invalid OpenAI key format."""
        valid, msg = check_api_key_format(
            "OPENAI_API_KEY",
            "invalid_key"
        )
        assert valid is False
        assert "sk-" in msg

    def test_anthropic_key_valid(self):
        """Test valid Anthropic key format."""
        valid, msg = check_api_key_format(
            "ANTHROPIC_API_KEY",
            "sk-ant-api03-1234567890"
        )
        assert valid is True

    def test_anthropic_key_invalid(self):
        """Test invalid Anthropic key format."""
        valid, msg = check_api_key_format(
            "ANTHROPIC_API_KEY",
            "sk-invalid"
        )
        assert valid is False

    def test_unknown_key_always_valid(self):
        """Test that unknown keys are always valid."""
        valid, msg = check_api_key_format(
            "SOME_UNKNOWN_KEY",
            "any_value"
        )
        assert valid is True

    def test_empty_value_invalid(self):
        """Test that empty values are invalid."""
        valid, msg = check_api_key_format("ANY_KEY", "")
        assert valid is False
        assert "empty" in msg.lower()


class TestFeatureDefinitions:
    """Tests for feature definitions."""

    def test_all_features_have_required_fields(self):
        """Test that all features have required fields."""
        required_fields = ["name", "description", "required_keys", "optional_keys", "default"]

        for feature_id, feature in FEATURES.items():
            for field in required_fields:
                assert field in feature, f"Feature {feature_id} missing {field}"

    def test_stylist_is_default_enabled(self):
        """Test that stylist feature is enabled by default."""
        assert FEATURES["stylist"]["default"] is True

    def test_fitness_requires_places_key(self):
        """Test that fitness requires Google Places key."""
        assert "GOOGLE_PLACES_API_KEY" in FEATURES["fitness"]["required_keys"]

    def test_travel_requires_amadeus_keys(self):
        """Test that travel requires Amadeus keys."""
        required = FEATURES["travel"]["required_keys"]
        assert "AMADEUS_CLIENT_ID" in required
        assert "AMADEUS_CLIENT_SECRET" in required


class TestCLICommands:
    """Tests for CLI commands."""

    @pytest.fixture
    def runner(self):
        """Create a CLI test runner."""
        return CliRunner()

    def test_help_command(self, runner):
        """Test the help command."""
        result = runner.invoke(main, ["--help"])
        assert result.exit_code == 0
        assert "GirlBot" in result.output
        assert "init" in result.output
        assert "run" in result.output
        assert "check" in result.output

    def test_version_command(self, runner):
        """Test the version command."""
        result = runner.invoke(main, ["--version"])
        assert result.exit_code == 0
        assert "0.1.0" in result.output

    def test_features_command(self, runner):
        """Test the features command."""
        with patch.dict(os.environ, {
            "ENABLE_STYLIST": "true",
            "ENABLE_FITNESS": "false",
            "ENABLE_TRAVEL": "false",
            "OPENAI_API_KEY": "sk-test",
        }):
            result = runner.invoke(main, ["features"])
            assert result.exit_code == 0
            assert "AI Stylist" in result.output
            assert "Fitness Discovery" in result.output
            assert "Travel Planning" in result.output

    def test_check_command_missing_token(self, runner, monkeypatch):
        """Test check command with missing token."""
        monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
        monkeypatch.delenv("OPENAI_API_KEY", raising=False)

        with patch("dotenv.load_dotenv"):
            result = runner.invoke(main, ["check"])
            assert "MISSING" in result.output or result.exit_code != 0

    def test_run_command_missing_token(self, runner, monkeypatch):
        """Test run command with missing token."""
        # Clear all environment variables that might have tokens
        monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
        monkeypatch.delenv("OPENAI_API_KEY", raising=False)

        # Mock dotenv.load_dotenv to prevent loading from file
        with patch("dotenv.load_dotenv"):
            result = runner.invoke(main, ["run"])
            assert result.exit_code != 0
            assert "TELEGRAM_BOT_TOKEN" in result.output

    def test_run_command_missing_openai(self, runner, monkeypatch):
        """Test run command with missing OpenAI key."""
        # Set token but not OpenAI key
        monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "123456789:ABCdefGHIjklMNOpqrSTUvwxYZ")
        monkeypatch.delenv("OPENAI_API_KEY", raising=False)

        # Mock dotenv.load_dotenv to prevent loading from file
        with patch("dotenv.load_dotenv"):
            result = runner.invoke(main, ["run"])
            assert result.exit_code != 0
            assert "OPENAI_API_KEY" in result.output

    def test_status_command_no_services(self, runner):
        """Test status command with no services running."""
        # Clear the circuit breakers
        from src.services.resilience import _circuit_breakers
        _circuit_breakers.clear()

        result = runner.invoke(main, ["status"])
        assert result.exit_code == 0
        # Should show empty or no services message


class TestCLIInit:
    """Tests for the init command."""

    @pytest.fixture
    def runner(self):
        """Create a CLI test runner."""
        return CliRunner()

    def test_init_creates_env_file(self, runner, tmp_path):
        """Test that init creates an .env file."""
        with runner.isolated_filesystem(temp_dir=tmp_path):
            # Simulate user input
            result = runner.invoke(main, ["init"], input="\n".join([
                "123456789:ABCdefGHIjklMNOpqrSTUvwxYZ1234567890",  # Telegram token
                "sk-test-openai-key-12345",  # OpenAI key
                "y",  # Enable stylist
                "n",  # Disable fitness
                "n",  # Disable travel
                "",   # Redis URL (default)
                "development",  # Environment
            ]))

            # Check file was created
            env_file = Path(".env")
            assert env_file.exists()

            # Check content
            content = env_file.read_text()
            assert "TELEGRAM_BOT_TOKEN" in content
            assert "OPENAI_API_KEY" in content
            assert "ENABLE_STYLIST=true" in content
